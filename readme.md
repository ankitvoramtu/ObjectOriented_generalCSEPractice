# Interview Submission
## Jobin Thomas
## Udacity Machine Learning Nanodegree


1. The goal for the problem, was to classify if one word is an anagram of the second word. In this case, s is the original word and t is the anagram. I separate s into all its substrings. For each substring, I add the lowercase and sorted version as a key to the new dictionary, and the value is the substring. I then add the lowercase and sorted version version of t as the key to the same dictionary, while t is the value. This is O(n). According to memory_profiler, this function uses 21.328 MiB of memory. 

2. The goal of this problem was to find the longest palindrome in a string parameter. I use a double for loop to iterate through all combination pieces of the string parameter. If a string piece equals the same string piece inversed, I append that to the possibleChoices array. I return the maximum length string in that array. If there are no strings in possibleChoices, meaning no palindromes in the original string parameter, the function returns 'none found'. This is O(n^2). According to memory_profiler, this function uses 21.523 MiB of memory. 

3. Next I find the minimum spanning tree using the prims algorithm. A minimum spanning tree is defined to reach every vertex, has a minimum total weight and there are no cycles in the connection of vertexes. Prims does this by choosing a random vertex and choosing the cheapest edge available that does not create cycles in the vertex connections. In my representation of the prims algorithm, first I created empty lists chosenEdges and chosenVertex. Next I append a random vertex from the keys of the dictionary which contains the 1st vertex as the key, and the 2nd vertex and edge as values for that key. Afterwards, I create a weightTable which sorts the dictionary, into a list. This makes it easier to work with. Next I make a sorted list of all vertexes so that the coming while loop can check and know when the algorithmic iterations can be stopped. Furerthermore inside this while loop, the algorithm iterates through each vertex in the weightTable checking if only one of two, of the vertex set, is contained in the chosenVertexes. This is xor. If conditions are met, the edge is appended and the new vertex is added in order to chosenVertex. The algorithm loop breaks the for loop and it is able to start again at the beginning of the while loop. When chosenVertex equals the completeVertexes, the prims algorithm is now complete and all edges that need to be selected have been selected. The chosen selection is converted back to dictionary form to meet function specifications and printed. This is O(n^2). According to memory_profiler, this function uses 21.328 MiB of memory. 

4. First I create the node class. It has functions to define the initial node value, and the other nodes it's connected to. It has another important function to connect the nodes it's connected to. I then make an array (arrayOfNodes) of objects, which holds all my nodes for the binary search tree. I go through my tree matrix (a adjacency matrix) using a for loop and add all the connections to each node in arrayOfNodes. Next I create another class called dynamicTree. The primary function is to find the least common denominator. It appends arrayOfNodes[r-1] to the roots variable which is built to hold nodes. It then for loops through the connects for that particular node, and appends the node to choosable array if the node is not contained in roots. Depending on the particular location in the most outer if statements, it chooses a minimum or maximum node and repeats the algorithm with the root now being the chosen node contained in choosableNode. If the chosen root is between both n1 and n2, it returns the root value, and the algorithm stops. This is O(n^2). According to memory_profiler, this function uses 21.414 MiB of memory. 

5. Similar to number 4, I create a class for node called Nodee. Although it only contains self.data and self.next. I build the linkedlist prior the execution of the function question5. It first calculates the length of the linkedlist by interating a length count while a next node exists. Next it iterates length-m times using a similar while loop. This returns the mth node value from the last node. This is an O(n). According to memory_profiler, this function uses 21.441 MiB of memory. 

